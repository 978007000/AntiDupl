using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AntiDuplWPF.ObjectModel.DirectoryFilter;
using AntiDuplWPF.ObjectModel.GettingNumber;
using AntiDuplWPF.ViewModel;

namespace AntiDuplWPF.ObjectModel.ConfigurableAction
{
    public class ConfigurableActionGenerator : PropertyChangedBase
    {
        public string Name { get; set; }

        public override string ToString()
        {
            return Name;
        }

        //internal void Excute()
        //{
        //    throw new NotImplementedException();
        //}

        private ObservableCollection<SelectCondition> _selectConditions;
        public ObservableCollection<SelectCondition> SelectConditions
        {
            get { return _selectConditions; }
            set
            {
                _selectConditions = value;
                RaisePropertyChangedEvent("SelectConditions");
            }
        }

        IGettingNumber _algorithmOfGettingNumberFromFileName;
        public IGettingNumber AlgorithmOfGettingNumberFromFileName
        {
            get { return _algorithmOfGettingNumberFromFileName; }
            set
            {
                _algorithmOfGettingNumberFromFileName = value;
                RaisePropertyChangedEvent("AlgorithmOfGettingNumberFromFileName");
            }
        }


        IDirectoryFilter _directoryFilter;
        public IDirectoryFilter DirectoryFilter
        {
            get { return _directoryFilter; }
            set
            {
                _directoryFilter = value;
                RaisePropertyChangedEvent("DirectoryFilter");
            }
        }


        BestSelectingByImagePropertyes _bestSelectingByImagePropertyes;
        public BestSelectingByImagePropertyes BestSelectingByImagePropertyes
        {
            get { return _bestSelectingByImagePropertyes; }
            set
            {
                _bestSelectingByImagePropertyes = value;
                RaisePropertyChangedEvent("BestSelectingByImagePropertyes");
            }
        }


        BestByPath _bestByPath;
        public BestByPath BestByPath
        {
            get { return _bestByPath; }
            set
            {
                _bestByPath = value;
                RaisePropertyChangedEvent("BestByPath");
            }
        }

        ActionOnDuplPair _actionOnDuplPair;
        public ActionOnDuplPair ActionOnDuplPair
        {
            get { return _actionOnDuplPair; }
            set
            {
                _actionOnDuplPair = value;
                RaisePropertyChangedEvent("ActionOnDuplPair");
            }
        }

        ActionOnDuplPair _elseActionOnDuplPair;
        public ActionOnDuplPair ElseActionOnDuplPair
        {
            get { return _elseActionOnDuplPair; }
            set
            {
                _elseActionOnDuplPair = value;
                RaisePropertyChangedEvent("ElseActionOnDuplPair");
            }
        }


        EqualAction _equalAction;
        public EqualAction EqualAction
        {
            get { return _equalAction; }
            set
            {
                _equalAction = value;
                RaisePropertyChangedEvent("EqualAction");
            }
        }

        internal IConfigurableAction GetAction(DuplPairViewModel item)
        {
            ImageInfoClass best = null;
            ImageInfoClass bad = null;
            bool skipImageProperty = GetBestByImageProperty(item, BestSelectingByImagePropertyes, ref best, ref bad);
            ImageInfoClass best2 = null;
            ImageInfoClass bad2 = null;
            GetBestByPath(item, BestByPath, ref best2, ref bad2);

            if (skipImageProperty)
            {
                best = best2;
                bad = bad2;
            }


            if (best == best2)
            {
                switch (ActionOnDuplPair)
                {
                    case ActionOnDuplPair.DeleteBadImage:
                        return new DeleteBadAction(bad, item);
                        break;
                    case ActionOnDuplPair.ReplaceBadImage:
                        return new ReplaceBadImageAction(best, bad);
                        break;
                    default:
                        throw new ArgumentException("Неизвестный параметр " + ActionOnDuplPair);
                        break;
                }
            }
            else
            {
                switch (ElseActionOnDuplPair)
                {
                    case ActionOnDuplPair.DeleteBadImage:
                        return new DeleteBadAction(bad, item);
                        break;
                    case ActionOnDuplPair.ReplaceBadImage:
                        return new ReplaceBadImageAction(best, bad);
                        break;
                    default:
                        throw new ArgumentException("Неизвестный параметр " + ElseActionOnDuplPair);
                        break;
                }
            }
            //}
            return null;
        }

        private void GetBestByPath(DuplPairViewModel item, ObjectModel.BestByPath bestByPath,
          ref ImageInfoClass best, ref ImageInfoClass bad)
        {
            switch (bestByPath)
            {
                case BestByPath.BestImageShouldHaveASmallerNumber:
                    var firstNumber = AlgorithmOfGettingNumberFromFileName.GetNumber(item.FirstFile.FileName);
                    var secondNumber = AlgorithmOfGettingNumberFromFileName.GetNumber(item.SecondFile.FileName);
                    if (!firstNumber.HasValue || !secondNumber.HasValue)
                        throw new Exception(String.Format("Не удалось получить номер из {0} или {1}",
                            item.FirstFile.FileName, item.SecondFile.FileName));
                    if (firstNumber.Value < secondNumber.Value)
                    {
                        best = item.FirstFile;
                        bad = item.SecondFile;
                    }
                    else if (secondNumber.Value < firstNumber.Value)
                    {
                        best = item.SecondFile;
                        bad = item.FirstFile;
                    }
                    else
                        throw new Exception("Номера равны!");
                    break;
                //case BestByPath.BestImageShouldBeInDirectory1:
                //    break;
                //case BestByPath.BestImageShouldBeInDirectory2:
                //    break;
                default:
                    throw new ArgumentException("Неизвестный параметр " + bestByPath);
                    break;
            }
        }

        private bool GetBestByImageProperty(DuplPairViewModel item, BestSelectingByImagePropertyes bestSelecting,
            ref ImageInfoClass best, ref ImageInfoClass bad)
        {
            switch (bestSelecting)
            {
                case BestSelectingByImagePropertyes.BigFileSize:
                    if (item.FirstFile.FileSize == item.SecondFile.FileSize)
                    {
                        switch (EqualAction)
                        {
                            case EqualAction.SkipImagePropertyCompare:
                                return true;
                                break;
                            //case EqualAction.BestHaveOldestLastAccessTime:
                            //    break;
                            default:
                                throw new ArgumentException("Неизвестный параметр " + EqualAction);
                                break;
                        }
                    }
                    else if (item.FirstFile.FileSize < item.SecondFile.FileSize)
                    {
                        best = item.SecondFile;
                        bad = item.FirstFile;
                        return false;
                    }
                    else if (item.FirstFile.FileSize > item.SecondFile.FileSize)
                    {
                        best = item.FirstFile;
                        bad = item.SecondFile;
                        return false;
                    }
                    break;
                default:
                    throw new ArgumentException("Неизвестный параметр " + bestSelecting);
                    break;
            }
            throw new Exception("Неожиданный выход из switch");
        }
    }
}
